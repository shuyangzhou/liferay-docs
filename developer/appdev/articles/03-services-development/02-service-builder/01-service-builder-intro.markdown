---
header-id: service-builder
---

# Service Builder

[TOC levels=1-4]

An application without reliable business logic or persistence isn't much of an
application at all. Unfortunately, writing your own persistence code often takes
a great deal of time. Fortunately, Liferay provides the Liferay Service Builder
to generate it for you. You might now be thinking, "What?! I hate code
generators!" Not to fear; you can still write your own persistence code if you
wish. And if you choose to use Service Builder, you can edit and customize the
code it generates. Regardless of how you produce your persistence code, you can
then use Service Builder to implement your app's business logic. 

This section demonstrates using Service Builder to:

-   Generate and customize your persistence framework

-   Implement your business logic

Liferay Service Builder is a model-driven code generation tool that lets you
define custom object models called entities. Service Builder generates a service
layer through object-relational mapping (ORM) technology that provides a clean
separation between your object model and code for the underlying database. This
frees you to add the necessary business logic for your application. Service
Builder takes an XML file (`service.xml`) as input and generates these layers
for your application: 

-   **Model layer:** defines objects to represent your project's entities. 

-   **Persistence layer:** saves entities to and retrieves entities from the 
    database and updates entities. 

-   **Service layer:** exposes create, read, update, and delete (CRUD) and 
    related operations for your entities as an API. 

Here are some key features these layers contain: 

-   Stubbed-out classes for implementing custom business logic 

-   Hibernate configurations 

-   Configurable caching support 

-   Flexibility and support for adding custom SQL queries and dynamic queries 

| **Note:** You don't have to use Service Builder to develop applications on
| @product@. It's entirely possible to develop them by writing custom code for
| database persistence using your persistence framework of choice. If you so
| choose, you can work directly with JPA or Hibernate.

## Customization via Implementation Classes

Each entity Service Builder generates contains these *implementation* classes: 

-   **Entity implementation** (`*Impl.java`): Is responsible for customizing 
    the entity. 

-   **Local service implementation** (`*LocalServiceImpl.java`): Is responsible 
    for calling the persistence layer to retrieve and store data entities. Local
    services contain the business logic and access the persistence layer. They
    can be invoked by client code running in the same Java Virtual Machine. 

-   **Remote service implementation** (`*ServiceImpl.java`): It's generated if 
    the `service.xml` is configured to generate remote services. Remote services
    usually have additional code for permission checking and are meant to be
    accessible from anywhere over the Internet or your local network. Service
    Builder automatically generates code that makes the remote services
    accessible. The remote services Service Builder generates include SOAP
    utilities and can be accessed via JSON or SOAP. 

These classes are where you implement custom business logic. They're the only
classes generated by Service Builder that are intended for customization.
Ensuring that all customizations take place in only a few classes facilitates
maintaining Service Builder projects. 

## Hibernate Configurations 

Service Builder uses the Hibernate persistence framework for object-relational
mapping. As a convenience to you, Service Builder hides the complexities of
using these technologies. You can take advantage of Object-Relational Mapping
(ORM) in your projects without having to manually set up a Hibernate environment
or make any configurations. 

## Caching 

Service Builder caches objects at three levels: *entity*, *finder*, and
*Hibernate*. By default, Liferay uses Ehcache as an underlying cache provider
for each of these cache levels. However, this is configurable via [portal
properties](/docs/7-2/deploy/-/knowledge_base/d/portal-properties). All you have
to do to enable entity and finder caching for an entity in your project is to
set the `cache-enabled=true` attribute of your entity's `<entity>` element in
your `service.xml` file.  [Liferay
Clustering](/docs/7-2/deploy/-/knowledge_base/d/enabling-cluster-link) describes
Liferay caching in a cluster. 

## Dynamic Query and Custom SQL Query

Service Builder is a flexible tool. It automates many of the common tasks
associated with creating database persistence code but it doesn't prevent you
from creating custom SQL queries. Service Builder lets you define custom SQL 
<!--Add link back for 'custom SQL queries' once article is available -->
queries in an XML file and implement finder methods to run the queries. This is 
useful, for example, for retrieving specific pieces of information from multiple 
tables via an SQL join. Service Builder also supports retrieving database 
information via dynamic query. Liferay's dynamic query API leverages Hibernate's 
criteria API. 

Service Builder is a proven application development solution used throughout
@product@ and Liferay applications. Each of its features mentioned here saves
lots of development time, both initial development time and time that would have
to be spent maintaining, extending, or customizing a project. Now [create your
own Service Builder
project](/docs/7-2/appdev/-/knowledge_base/a/creating-a-service-builder-project). 
